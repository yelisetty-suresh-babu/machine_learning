# -*- coding: utf-8 -*-
"""exercise_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L2OIw9BqLhoaHX7s-t8Cdvy4iov_NtK8
"""

import pandas as pd
import matplotlib.pyplot as plt
from matplotlib import pyplot
import numpy as np
import os

# data=pd.read_csv('/Users/yelisettysureshbabu/Downloads/DSA/machine learning/exercise1_traindata.txt',names=['x','y'])
data=pd.read_csv(f'{os.getcwd()}/exercise1_traindata.txt',names=['x','y'])

data.head()

# data_new=pd.DataFrame(data,columns=['x','y'])
# data_new.head()

data_y=data.drop("x",axis=1)
data_x=data['x']
data_y.shape

# plt.scatter(data_x,data_y);
# plt.show()
plt.plot(data_x,data_y, 'ro', ms=10, mec='k')
plt.ylabel('Profit in $10,000')
plt.xlabel('Population of City in 10,000s')
m=data_y.size

"""cost_function_calculator:

"""

def computeCost(data_x, data_y, theta):
  l=[]
  for x in data_x:
    l.append(theta[0]+theta[1]*x)
  nl=[]
  t=data_y.to_numpy()
  t=t.tolist()
  for lt in t:
    nl.append(lt[0])
  i=0
  fl=[]
  for i in range(len(l)):
    fl.append((l[i]-nl[i])**2)
  fln=np.array(fl)
  return (1/(2*m))*np.sum(fln)

v=computeCost(data_x,data_y,[-1,2])
print(v)

def update(nx,theta):
  tl=nx.tolist()
  ans=[]
  for i in tl:
    ans.append(theta[0]+theta[1]*i)
  return np.array(ans)
def gradientDescent(x, y, theta, alpha, num_iters):

  nx=x.to_numpy().flatten()
  ny=y.to_numpy().flatten()

  h=[]
  for i in range(num_iters):
    theta[0]=theta[0]-(alpha *((1/m) * np.sum(nx - ny)))
    theta[1]=theta[1]-(alpha *((1/m) * np.sum(nx - ny)))
    nx=update(nx,theta)
    h.append(computeCost(x, y, theta))
  print(theta)

gradientDescent(data_x,data_y,[m,m],0.1,415)

